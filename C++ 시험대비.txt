auto_ptr
배열 안됨
대입연산자 사용시 없어짐

share_ptr

unique_ptr
#include <memory> 필요
배열 사용시 unique_ptr<int[]> buf(new int[10);
클래스 사용시 unique_ptr<Point> buf(new Point);
혼자 쓰는 포인터라 같이 가리킬 수 없음?

초기회리스트가 중요한 이유 2가지
기능상 안되는 게 된다.(ex const or 참조자)초기값이 있어야 하는데 없이 선언만하고 초기화리스트에서 값을 주면 됨)
속도가 빠르다.
생성자를 하나 만들면 디폴트 생성자는 안만들어진다.

//클래스멤버의 포인터가 있을 때 복사생성자 만들어야함
//매개변수, 반환할 때, 변수 선언할 때 복사생성자 호출됨

this 포인터는 그 값이 결정되어 있지 않은 포인터이다.
왜냐하면 this 포인터는 this가 사용된 객체 자신의 주소값을 정보로 담고 있는 포인터이기 때문이다.

#include <vector>
vector<int> test;
test.push_back(b);
test.pop_back();

const => mutable int ~~

정적 멤버는 인스턴스 선언 없이 호출할 수 있다. 
: 예) CTest::PrintData(); ?
 정적 메서드는 this 포인터가 없다. ? 
정적 메소드에서 일반 멤버 변수를 사용할 수 없다. ? 
정적 변수는 반드시 선언과 정의를 분리한다. ? 
정적 변수는 ‘동시성’(예를 들어 멀티스레드 기반 프로그램)을 지원하지 못해 문제가 발생하므로 꼭 필요한 경우에만 제한 적으로 사용한다

while(v.empty()!=true){ 
v.erase(v.begin()+i)

vector는 생성과 소멸을 하는데 상당한 시간이 소요된다.
 따라서 vector의 장점이 많지만 성능 때문에 기존의 배열 을 사용하는 경우도 많다. ?
 이 문제를 해결하기 위해 C++11에서는 std::array를 새롭 게 제시하였다.
 array 클래스를 사용하면 벡터의 장점과 기존 배열의 성능을 동시에 누릴 수 있다.

array<int,3>list{1,2,3};

동적 할당한 인스턴스를 자동으로 삭제해주는 포인터
auto_ptr ? 동적 할당한 인스턴스를 자동으로 삭제
shared_ptr ? 포인팅 횟수를 계수해서 0이 되면 대상을 삭제
unique_ptr ? 한 대상을 오로지 한 포인터로만 포인팅
하나의 소유자만 허용
weak_ptr ? shared_ptr에 접근 ? 
참조는 못함: 참조하려면 lock() 메서드 사용

배열을 지원하지 않음
auto_ptr<CMyData> ptrTest(new CMyData[3]); -> error ? 
대입 오류 
ptrNew = ptrTest; // 원본 포인터가 null 됨

unique_ptr<int[]> buf(new int[10]);

포인팅 횟수를 계산해서 0이 되면 대상을 삭제
배열로 객체를 삭제할 수 있는 방법을 제공
배열로 대상을 삭제하는 함수를 등록
void RemoveTest(CTest *pTest) { delete [ ] pTest; } 
shared_ptr<CTest>  ptr (new CTest[3], RemoveTest); //ptr이 소멸할 때 자동으로 호출

weak_ptr
약하게 링크된 포인터를 래핑
리소스를 가리키는 weak_ptr 개체는 리소스의 참조 횟수에 영향 을 주지 않는다
해당 리소스를 관리하는 마지막 shared_ptr 개체가 삭제되면 해 당 리소스를 가리키는 weak_ptr 개체가 있는 경우에도 리소스가 해제됨
이는 데이터 구조에서 순환을 방지하는 데 필요 

unique_ptr<int[]>buf(newint[10]);
unique_ptr<int> p(new int);

int a = 5;
	int b = 3;
	const int *p = &a;
	int * const q = &a;

	q = &b;
	*q = 7;

	p = &b;
	*p = 3;